// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package users

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const all = `-- name: All :one
SELECT count(*) FROM "User"
`

// All returns the total number of [User] records, including deleted record(s).
func (q *Queries) All(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, all)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const attributes = `-- name: Attributes :one
SELECT id, name, "display-name", email, avatar, marketing, creation, modification, deletion
FROM "User"
WHERE (id) = $1::bigserial
  AND (deletion) IS NULL
LIMIT 1
`

// Attributes will use the user's [User.ID] to hydrate all available [User] attribute(s). Note that the following call is more taxing on the database.
func (q *Queries) Attributes(ctx context.Context, db DBTX, id int64) (User, error) {
	row := db.QueryRow(ctx, attributes, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Email,
		&i.Avatar,
		&i.Marketing,
		&i.Creation,
		&i.Modification,
		&i.Deletion,
	)
	return i, err
}

const count = `-- name: Count :one
SELECT count(*) FROM "User" WHERE (email) = $1::text AND (deletion) IS NULL
`

// Count returns 0 or 1 depending on if a [User] record matching the provided email exists.
func (q *Queries) Count(ctx context.Context, db DBTX, email string) (int64, error) {
	row := db.QueryRow(ctx, count, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const create = `-- name: Create :one
INSERT INTO "User" (email) VALUES ($1) RETURNING id, name, "display-name", email, avatar, marketing, creation, modification, deletion
`

// Create will create a new [User] record.
func (q *Queries) Create(ctx context.Context, db DBTX, email string) (User, error) {
	row := db.QueryRow(ctx, create, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Email,
		&i.Avatar,
		&i.Marketing,
		&i.Creation,
		&i.Modification,
		&i.Deletion,
	)
	return i, err
}

const delete = `-- name: Delete :exec
DELETE FROM "User" WHERE id = $1
`

// Delete performs a hard database delete on a [User] record.
func (q *Queries) Delete(ctx context.Context, db DBTX, id int64) error {
	_, err := db.Exec(ctx, delete, id)
	return err
}

const deleteByEmail = `-- name: DeleteByEmail :exec
DELETE FROM "User" WHERE email = $1
`

// DeleteByEmail performs a hard database delete on a [User] record.
func (q *Queries) DeleteByEmail(ctx context.Context, db DBTX, email string) error {
	_, err := db.Exec(ctx, deleteByEmail, email)
	return err
}

const list = `-- name: List :many
SELECT id, name, "display-name", email, avatar, marketing, creation, modification, deletion FROM "User" WHERE (deletion) IS NULL
`

// List returns all active User record(s).
func (q *Queries) List(ctx context.Context, db DBTX) ([]User, error) {
	rows, err := db.Query(ctx, list)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Email,
			&i.Avatar,
			&i.Marketing,
			&i.Creation,
			&i.Modification,
			&i.Deletion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const me = `-- name: Me :one
SELECT id, name, "display-name", email, avatar, marketing, creation, modification, deletion FROM "User" WHERE email = $1
`

// Me will return a [User] and all associated attribute(s) when provided the User's email address.
func (q *Queries) Me(ctx context.Context, db DBTX, email string) (User, error) {
	row := db.QueryRow(ctx, me, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Email,
		&i.Avatar,
		&i.Marketing,
		&i.Creation,
		&i.Modification,
		&i.Deletion,
	)
	return i, err
}

const total = `-- name: Total :one
SELECT count(*) FROM "User" WHERE (deletion) IS NULL
`

// Total returns the total number of [User] records, excluding deleted record(s).
func (q *Queries) Total(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, total)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateUserAvatar = `-- name: UpdateUserAvatar :exec
UPDATE "User" SET avatar = $2, modification = $3 WHERE (email) = $1 AND (deletion) IS NULL
`

type UpdateUserAvatarParams struct {
	Email        string             `db:"email" json:"email"`
	Avatar       *string            `db:"avatar" json:"avatar"`
	Modification pgtype.Timestamptz `db:"modification" json:"modification"`
}

// UpdateUserAvatar will update a provided [User] with their specified avatar.
func (q *Queries) UpdateUserAvatar(ctx context.Context, db DBTX, arg *UpdateUserAvatarParams) error {
	_, err := db.Exec(ctx, updateUserAvatar, arg.Email, arg.Avatar, arg.Modification)
	return err
}

const users = `-- name: Users :many
SELECT id, name, "display-name", email, avatar, marketing, creation, modification, deletion FROM "User"
`

// Users returns all User record(s).
func (q *Queries) Users(ctx context.Context, db DBTX) ([]User, error) {
	rows, err := db.Query(ctx, users)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Email,
			&i.Avatar,
			&i.Marketing,
			&i.Creation,
			&i.Modification,
			&i.Deletion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
