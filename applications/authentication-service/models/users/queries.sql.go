// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package users

import (
	"context"
)

const clean = `-- name: Clean :exec
DELETE FROM "User" WHERE (email) = ($1::text)
`

// Clean performs a hard delete on the [User] database record, regardless if a soft delete has been performed, and only by email. This function should only be used in test(s).
func (q *Queries) Clean(ctx context.Context, db DBTX, email string) error {
	_, err := db.Exec(ctx, clean, email)
	return err
}

const count = `-- name: Count :one
SELECT count(*) FROM "User" WHERE (email) = $1::text AND (deletion) IS NULL
`

// Count returns 0 or 1 depending on if a User record matching the provided email exists.
func (q *Queries) Count(ctx context.Context, db DBTX, email string) (int64, error) {
	row := db.QueryRow(ctx, count, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const create = `-- name: Create :one
INSERT INTO "User" (email, password) VALUES ($1, $2) RETURNING id, email, password, creation, modification, deletion
`

type CreateParams struct {
	Email    string `db:"email" json:"email"`
	Password string `db:"password" json:"-"`
}

// Create creates a new [User] database record.
func (q *Queries) Create(ctx context.Context, db DBTX, arg *CreateParams) (User, error) {
	row := db.QueryRow(ctx, create, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Creation,
		&i.Modification,
		&i.Deletion,
	)
	return i, err
}

const delete = `-- name: Delete :exec
DELETE FROM "User" WHERE (id, email) = ($1, $2::text)
`

type DeleteParams struct {
	ID    int64  `db:"id" json:"id"`
	Email string `db:"email" json:"email"`
}

// Delete performs a hard delete on the [User] database record, regardless if a soft delete has been performed.
func (q *Queries) Delete(ctx context.Context, db DBTX, arg *DeleteParams) error {
	_, err := db.Exec(ctx, delete, arg.ID, arg.Email)
	return err
}

const extract = `-- name: Extract :one
SELECT id, email, password, creation, modification, deletion FROM "User" WHERE (id, email) = ($1, $2::text)
`

type ExtractParams struct {
	ID    int64  `db:"id" json:"id"`
	Email string `db:"email" json:"email"`
}

// Extract retrieves a given [User] database record, regardless of its deletion status.
func (q *Queries) Extract(ctx context.Context, db DBTX, arg *ExtractParams) (User, error) {
	row := db.QueryRow(ctx, extract, arg.ID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Creation,
		&i.Modification,
		&i.Deletion,
	)
	return i, err
}

const get = `-- name: Get :one
SELECT id, email, password FROM "User" WHERE email = $1 AND (deletion) IS NULL
`

type GetRow struct {
	ID       int64  `db:"id" json:"id"`
	Email    string `db:"email" json:"email"`
	Password string `db:"password" json:"-"`
}

func (q *Queries) Get(ctx context.Context, db DBTX, email string) (GetRow, error) {
	row := db.QueryRow(ctx, get, email)
	var i GetRow
	err := row.Scan(&i.ID, &i.Email, &i.Password)
	return i, err
}

const remove = `-- name: Remove :exec
UPDATE "User" SET (modification, deletion) = (now(), now()) WHERE (id, email) = ($1, $2::text) AND (deletion) IS NULL
`

type RemoveParams struct {
	ID    int64  `db:"id" json:"id"`
	Email string `db:"email" json:"email"`
}

// Remove performs a soft delete on the [User] database record.
func (q *Queries) Remove(ctx context.Context, db DBTX, arg *RemoveParams) error {
	_, err := db.Exec(ctx, remove, arg.ID, arg.Email)
	return err
}
