// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package verifications

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const count = `-- name: Count :one
SELECT count(*) FROM "Verification" WHERE (email) = $1::text AND (deletion) IS NULL
`

// Count returns 0 or 1 depending on if a Verification record matching the provided email exists.
func (q *Queries) Count(ctx context.Context, db DBTX, email string) (int64, error) {
	row := db.QueryRow(ctx, count, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const create = `-- name: Create :one
INSERT INTO "Verification" (email, code) VALUES ($1, $2) RETURNING id, email, code, verified, creation, modification, deletion
`

type CreateParams struct {
	Email string `db:"email" json:"email"`
	Code  string `db:"code" json:"code"`
}

// Create establishes a new [Verification] database record.
func (q *Queries) Create(ctx context.Context, db DBTX, arg *CreateParams) (Verification, error) {
	row := db.QueryRow(ctx, create, arg.Email, arg.Code)
	var i Verification
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Code,
		&i.Verified,
		&i.Creation,
		&i.Modification,
		&i.Deletion,
	)
	return i, err
}

const delete = `-- name: Delete :exec
DELETE FROM "Verification" WHERE id = $1
`

// Delete performs a hard database delete on a [Verification] record.
func (q *Queries) Delete(ctx context.Context, db DBTX, id int64) error {
	_, err := db.Exec(ctx, delete, id)
	return err
}

const deleteByEmail = `-- name: DeleteByEmail :exec
DELETE FROM "Verification" WHERE email = $1
`

// DeleteByEmail performs a hard database delete on a [Verification] record.
func (q *Queries) DeleteByEmail(ctx context.Context, db DBTX, email string) error {
	_, err := db.Exec(ctx, deleteByEmail, email)
	return err
}

const get = `-- name: Get :one
SELECT id, email, code, verified, creation, modification, deletion FROM "Verification" WHERE (email) = $1::text AND (deletion) IS NULL
`

// Get returns a fully hydrated [Verification] database record if a match is found via email.
func (q *Queries) Get(ctx context.Context, db DBTX, email string) (Verification, error) {
	row := db.QueryRow(ctx, get, email)
	var i Verification
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Code,
		&i.Verified,
		&i.Creation,
		&i.Modification,
		&i.Deletion,
	)
	return i, err
}

const status = `-- name: Status :one
SELECT email, verified FROM "Verification" WHERE (email) = $1 AND (deletion) IS NULL
`

type StatusRow struct {
	Email    string `db:"email" json:"email"`
	Verified bool   `db:"verified" json:"verified"`
}

// Status returns a partially hydrated [Verification] database record only including the user's email and verified attribute(s).
func (q *Queries) Status(ctx context.Context, db DBTX, email string) (StatusRow, error) {
	row := db.QueryRow(ctx, status, email)
	var i StatusRow
	err := row.Scan(&i.Email, &i.Verified)
	return i, err
}

const verify = `-- name: Verify :exec
UPDATE "Verification" SET verified = true, modification = $2 WHERE (email) = $1 AND (deletion) IS NULL
`

type VerifyParams struct {
	Email        string             `db:"email" json:"email"`
	Modification pgtype.Timestamptz `db:"modification" json:"modification"`
}

// Verify updates the [Verification] database record with a verified state.
func (q *Queries) Verify(ctx context.Context, db DBTX, arg *VerifyParams) error {
	_, err := db.Exec(ctx, verify, arg.Email, arg.Modification)
	return err
}
